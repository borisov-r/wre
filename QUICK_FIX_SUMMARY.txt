╔═══════════════════════════════════════════════════════════════════════╗
║                ISR NOT FIRING - FIX APPLIED                           ║
╚═══════════════════════════════════════════════════════════════════════╝

PROBLEM:
--------
Your ESP32 microcontroller showed Live pins changing (encoder working),
but ISR_Calls always stayed at 0, meaning the interrupt handler never fired.

ROOT CAUSE:
-----------
The subscribe() calls were incorrectly wrapped in an "unsafe" block.
This confused Rust's compiler and prevented interrupts from working.

THE FIX:
--------
✓ Removed the unnecessary "unsafe" wrapper around subscribe() calls
✓ Moved "unsafe" to only wrap the actual FFI calls inside closures
✓ This allows Rust's RAII system to properly track subscriptions

FILES CHANGED:
--------------
- src/main.rs: Fixed the unsafe block placement (1 file, 39 additions, 38 deletions)
- UNSAFE_BLOCK_FIX.md: Comprehensive documentation explaining the fix

WHAT TO DO NOW:
---------------
1. Flash the new firmware to your ESP32
2. The interrupts should now fire correctly
3. You should see ISR_Calls incrementing when you rotate the encoder
4. State, Value, and Angle should all update properly

EXPECTED OUTPUT AFTER FIX:
--------------------------
Before (broken):
  ISR[CLK=0 DT=0] State=0x00 Value=0 Angle=0.0° ISR_Calls=0  ← Stuck at 0!

After (working):
  ISR[CLK=1 DT=1] State=0x01 Value=1 Angle=0.5° ISR_Calls=5  ← Incrementing!

TECHNICAL DETAILS:
------------------
This was the third layer of ISR fixes needed:
1. Explicit variable capture in closures
2. Proper RAII lifetime (keeping subscription handles alive)
3. Correct unsafe/safe boundary (this fix)

All three layers must be correct for ESP32 interrupts to work in Rust.

For more details, see: UNSAFE_BLOCK_FIX.md

═══════════════════════════════════════════════════════════════════════
